//
//  PBWebGitController.m
//  GitTest
//
//  Created by Pieter de Bie on 14-06-08.
//  Copyright 2008 __MyCompanyName__. All rights reserved.
//

#import "PBWebHistoryController.h"
#import "PBWebBridge.h"
#import "GitX-Swift.h"

@interface PBWebHistoryController ()
- (NSDictionary *)bridgeDictionaryForCommit:(PBGitCommit *)commit currentRef:(NSString *)currentRef;
- (NSArray *)bridgeRefsForCommit:(PBGitCommit *)commit;
@end

@implementation PBWebHistoryController

@synthesize diff;

- (void) awakeFromNib
{
	startFile = @"history";
	repository = historyController.repository;
	[super awakeFromNib];

	self.bridge.newWindowHandler = ^BOOL (id<PBWebBridge> bridge, NSURLRequest *request) {
		NSURL *url = request.URL;
		if (!url) {
			return NO;
		}
		[[NSWorkspace sharedWorkspace] openURL:url];
		return YES;
	};
	[historyController addObserver:self forKeyPath:@"webCommit" options:0 context:@"ChangedCommit"];
}

- (void)closeView
{
	[historyController removeObserver:self forKeyPath:@"webCommit"];

	[super closeView];
}

- (void) didLoad
{
	currentSha = nil;
	[self changeContentTo: historyController.webCommit];
}

- (void) observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    if ([(__bridge NSString *)context isEqualToString: @"ChangedCommit"])
		[self changeContentTo: historyController.webCommit];
	else
		[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
}

- (void) changeContentTo: (PBGitCommit *) content
{
	if (content == nil)
		return;

	NSString *headRef = [[[historyController repository] headRef] simpleRef];
	NSDictionary *commitPayload = [self bridgeDictionaryForCommit:content currentRef:headRef];
	NSString *sha = commitPayload[@"sha"] ?: @"";

	if ([currentSha isEqualToString:sha]) {
		[self sendBridgeEventWithType:@"commitRefsUpdated" payload:@{ @"commit": commitPayload ?: @{}, @"sha": sha ?: @"" }];
		return;
	}

	[self sendBridgeEventWithType:@"commitSelected"
					 payload:@{ @"commit": commitPayload ?: @{},
							@"currentRef": headRef ?: @"",
							@"sha": sha ?: @"" }];
	currentSha = sha;

	// Load extended commit details asynchronously
	NSMutableArray *taskArguments = [NSMutableArray arrayWithObjects:@"show", @"--pretty=raw", @"-M", @"--no-color", currentSha, nil];
	if (![PBGitDefaults showWhitespaceDifferences])
		[taskArguments insertObject:@"-w" atIndex:1];

	NSString *shaToLoad = currentSha;
	[repository executeGitCommandAsync:taskArguments completion:^(NSString *output, NSString *error, int exitCode) {
		if (!output)
			return;

		NSDictionary *payload = @{ @"sha": shaToLoad ?: @"", @"details": output ?: @"" };
		[self sendBridgeEventWithType:@"commitDetails" payload:payload];
	}];
}

- (void)selectCommit:(NSString *)sha
{
	// Validate SHA using git rev-parse before creating PBCommitID
	NSError *error = nil;
	NSString *validatedSHA = [historyController.repository executeGitCommand:@[@"rev-parse", @"--verify", [NSString stringWithFormat:@"%@^{commit}", sha]] error:&error];
	
	if (!error && validatedSHA) {
		validatedSHA = [validatedSHA stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
		
		NSString *oid = validatedSHA;
		[historyController selectCommit: oid];
	} else {
		if (error) {
			NSLog(@"Error validating commit SHA %@: %@", sha, error.localizedDescription);
		} else {
			NSLog(@"Invalid commit SHA: %@", sha);
		}
		// Fallback to original behavior for compatibility
		NSString *oid = sha;
		[historyController selectCommit: oid];
	}
}

- (void) sendKey: (NSString*) key
{
	if (key.length == 0)
		return;

	NSDictionary *payload = @{ @"key": key ?: @"" };
	[self sendBridgeEventWithType:@"historyKeyCommand" payload:payload];
}

- (void)handleBridgeMessage:(NSString *)type payload:(NSDictionary *)payload
{
	if ([type isEqualToString:@"selectCommit"]) {
		NSString *sha = payload[@"sha"];
		if ([sha isKindOfClass:[NSString class]] && sha.length > 0) {
			[self selectCommit:sha];
		} else {
			NSLog(@"PBWebHistoryController: selectCommit payload missing sha: %@", payload);
		}
		return;
	}

	if ([type isEqualToString:@"copySource"]) {
		[self copySource];
		return;
	}

	if ([type isEqualToString:@"checkAutogeneratedFiles"]) {
		[self checkAutogeneratedFiles:payload];
		return;
	}

	[super handleBridgeMessage:type payload:payload];
}

- (void)checkAutogeneratedFiles:(NSDictionary *)payload
{
	NSString *sha = payload[@"sha"];
	NSArray *files = payload[@"files"];

	if (![sha isKindOfClass:[NSString class]] || sha.length == 0 ||
		![files isKindOfClass:[NSArray class]] || files.count == 0) {
		[self sendBridgeEventWithType:@"autogeneratedFilesResult"
							  payload:@{ @"sha": sha ?: @"", @"autogenerated": @[] }];
		return;
	}

	// Build commands to check each file's first 5 lines
	NSMutableArray *autogeneratedFiles = [NSMutableArray array];
	dispatch_group_t group = dispatch_group_create();

	for (NSString *filePath in files) {
		if (![filePath isKindOfClass:[NSString class]] || filePath.length == 0)
			continue;

		dispatch_group_enter(group);

		// Use git show to get file content at this commit
		NSString *objectPath = [NSString stringWithFormat:@"%@:%@", sha, filePath];
		[repository executeGitCommandAsync:@[@"show", objectPath] completion:^(NSString *output, NSString *error, int exitCode) {
			if (exitCode == 0 && output.length > 0) {
				// Check first 5 lines for "DO NOT EDIT"
				NSArray *lines = [output componentsSeparatedByString:@"\n"];
				NSUInteger linesToCheck = MIN(lines.count, (NSUInteger)5);

				for (NSUInteger i = 0; i < linesToCheck; i++) {
					if ([lines[i] rangeOfString:@"DO NOT EDIT"].location != NSNotFound) {
						@synchronized (autogeneratedFiles) {
							[autogeneratedFiles addObject:filePath];
						}
						break;
					}
				}
			}
			dispatch_group_leave(group);
		}];
	}

	dispatch_group_notify(group, dispatch_get_main_queue(), ^{
		[self sendBridgeEventWithType:@"autogeneratedFilesResult"
							  payload:@{ @"sha": sha ?: @"", @"autogenerated": [autogeneratedFiles copy] }];
	});
}

- (void) copySource
{
	static NSString *const kCopySourceScript = @"(function(){\n"
		"  if (!document || !document.documentElement) { return ''; }\n"
		"  return document.documentElement.outerHTML;\n"
		"})();";

	[self.bridge evaluateJavaScript:kCopySourceScript completion:^(id result, NSError *error) {
		if (error) {
			NSLog(@"PBWebHistoryController: Failed to copy source: %@", error);
			return;
		}

		NSString *source = nil;
		if ([result isKindOfClass:[NSString class]]) {
			source = result;
		} else if ([result respondsToSelector:@selector(description)]) {
			source = [result description];
		}

		if (source.length == 0) {
			return;
		}

			dispatch_async(dispatch_get_main_queue(), ^{
				NSPasteboard *pasteboard = [NSPasteboard generalPasteboard];
				[pasteboard declareTypes:@[NSPasteboardTypeString] owner:self];
				[pasteboard setString:source forType:NSPasteboardTypeString];
		});
	}];
}

- (NSArray *)contextMenuItemsForBridge:(id<PBWebBridge>)bridge elementInfo:(NSDictionary *)elementInfo defaultMenuItems:(NSArray *)defaultMenuItems
{
	#pragma unused(bridge)
	NSString *type = [[elementInfo[@"type"] description] lowercaseString];
	if ([type isEqualToString:@"refs"]) {
		NSString *selectedRefString = [elementInfo[@"refText"] description];
		if (selectedRefString.length > 0) {
			for (PBGitRef *ref in historyController.webCommit.refs) {
				if ([[ref shortName] isEqualToString:selectedRefString]) {
					return [contextMenuDelegate menuItemsForRef:ref];
				}
			}
			NSLog(@"Could not find selected ref for context menu: %@", selectedRefString);
		}
		return defaultMenuItems;
	}

	if ([type isEqualToString:@"representedfile"]) {
		return nil;
	}

	if ([type isEqualToString:@"image"]) {
		NSMutableArray *filtered = [NSMutableArray array];
		for (NSMenuItem *item in defaultMenuItems) {
			SEL action = item.action;
			BOOL isCopyAction = (action == @selector(copy:)) || (action == NSSelectorFromString(@"copyImageToClipboard:"));
			BOOL titleIndicatesCopy = [[item title] rangeOfString:@"copy" options:NSCaseInsensitiveSearch].location != NSNotFound;
			if (isCopyAction || titleIndicatesCopy) {
				[filtered addObject:item];
			}
		}
		return filtered.count ? [filtered copy] : nil;
	}

	return defaultMenuItems;
}

- (NSString *)gitHubBaseURLFromOrigin
{
	NSError *error = nil;
	NSString *originURL = [historyController.repository executeGitCommand:@[@"config", @"--get", @"remote.origin.url"] error:&error];

	if (error || !originURL)
		return nil;

	originURL = [originURL stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
	if (originURL.length == 0)
		return nil;

	// Handle SSH format: git@github.com:user/repo.git
	if ([originURL hasPrefix:@"git@github.com:"]) {
		NSString *path = [originURL substringFromIndex:@"git@github.com:".length];
		if ([path hasSuffix:@".git"])
			path = [path substringToIndex:path.length - 4];
		return [NSString stringWithFormat:@"https://github.com/%@", path];
	}

	// Handle HTTPS format: https://github.com/user/repo.git
	if ([originURL hasPrefix:@"https://github.com/"] || [originURL hasPrefix:@"http://github.com/"]) {
		NSString *url = originURL;
		if ([url hasSuffix:@".git"])
			url = [url substringToIndex:url.length - 4];
		// Normalize to https
		if ([url hasPrefix:@"http://"])
			url = [@"https://" stringByAppendingString:[url substringFromIndex:@"http://".length]];
		return url;
	}

	return nil;
}

- (NSDictionary *)bridgeDictionaryForCommit:(PBGitCommit *)commit currentRef:(NSString *)currentRef
{
	if (!commit)
		return @{};

	NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];
	NSString *sha = [commit realSha] ?: [commit sha] ?: @"";
	dictionary[@"sha"] = sha;
	if (sha.length >= 1) {
		NSUInteger shortLength = MIN((NSUInteger)7, sha.length);
		dictionary[@"shortSha"] = [sha substringToIndex:shortLength];
	} else {
		dictionary[@"shortSha"] = @"";
	}

	dictionary[@"subject"] = [commit subject] ?: @"";
	dictionary[@"authorName"] = [commit author] ?: @"";
	dictionary[@"committerName"] = [commit committer] ?: @"";
	NSArray *parents = [commit parents];
	dictionary[@"parents"] = parents ? [parents copy] : @[];
	dictionary[@"refs"] = [self bridgeRefsForCommit:commit];
	dictionary[@"currentRef"] = currentRef ?: @"";

	// Add GitHub URL if available
	NSString *gitHubBase = [self gitHubBaseURLFromOrigin];
	if (gitHubBase && sha.length > 0) {
		dictionary[@"gitHubUrl"] = [NSString stringWithFormat:@"%@/commit/%@", gitHubBase, sha];
	}

	return dictionary;
}

- (NSArray *)bridgeRefsForCommit:(PBGitCommit *)commit
{
	NSArray *refs = [commit refs];
	if (![refs count])
		return @[];

	NSMutableArray *result = [NSMutableArray arrayWithCapacity:[refs count]];
	for (PBGitRef *ref in refs) {
		if (![ref isKindOfClass:[PBGitRef class]])
			continue;

		NSString *refName = [ref refishName] ?: @"";
		NSString *shortName = [ref shortName];
		if (!shortName || shortName.length == 0)
			shortName = refName;

		NSMutableDictionary *serializedRef = [NSMutableDictionary dictionary];
		serializedRef[@"ref"] = refName;
		serializedRef[@"shortName"] = shortName ?: @"";
		serializedRef[@"type"] = [ref type] ?: @"";
		serializedRef[@"refType"] = [ref refishType] ?: @"";

		[result addObject:serializedRef];
	}

	return result;
}

- getConfig:(NSString *)key
{
	NSError *error = nil;
	NSString *value = [historyController.repository executeGitCommand:@[@"config", @"--get", key] error:&error];
	
	if (!error && value) {
		return [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
	}
	
	return nil;
}



@end
